
---
1. sessionStorageにトークンが平文保存
BFFなしのSPA構成上やむを得ないが、同一オリジンのXSSで全トークンが窃取される。

2. checkExistingTokensがトークンの妥当性を検証しない
App.vue:83-89 — sessionStorageに値が存在すればdecodeJwtPayloadでデコードして表
示するだけ。JWT署名の検証もなく、expチェックもないため、出鱈目な値や期限切れト
ークンでもログイン済みとして扱われる。

3. JWTの署名検証なし（クライアント側）
tokenStore.js:59-68 — decodeJwtPayloadはペイロードをBase64デコードするだけで、
署名(header.payload.signatureの第3部)を一切検証していない。攻撃者がsessionStor
ageに任意のクレームを持つ偽JWTをセットすれば、UIは任意のユーザー情報を「正規」
として表示する。APIコールにこのトークンを使う拡張をした場合、サーバー側で弾か
れるとはいえ、クライアント側の認可判断は完全にバイパスされる。

4. decodeJwtPayloadのエラーハンドリング欠如
同関数は不正な入力（.を含まない文字列、不正なBase64等）に対してtry-catchがなく
、例外で画面が壊れる。攻撃者がsessionStorageに細工した値をセットした場合にDeni
al of Serviceになり得る。

5. トークン有効期限のクライアント側チェックのみ
TokenDetails.vue — isExpiredで期限切れ表示はしているが、checkExistingTokens側
では期限切れトークンでもログイン済みとして扱う。期限切れトークンを使ったAPI呼
び出しの拡張時にそのまま使われるリスクがある。

6. Open Redirect の可能性
cognito.js:30-36 — config.jsonが取得できた場合、redirectUriとlogoutUriがそのJS
ONの値に従う。もし/config.jsonが攻撃者によって改ざんされた場合（例：CDN poison
ing、パストラバーサル等）、任意のURLにリダイレクトされうる。Cognito側のallowed
callback URLで緩和はされるが、logoutUriは制約が緩いケースがある。

7. config.jsonにclientIdが平文で含まれる
Public clientなのでclient_secretはないが、clientIdとcognitoDomainが/config.jso
nとして公開静的ファイルに含まれる。これ自体はPKCEフローでは許容されるが、攻撃
者がこれらの情報を使って大量のHosted
UIリクエストを送り、Cognito側のレートリミットに到達させる攻撃が可能。

8. CSRFトークン / stateパラメータの欠如
cognito.js:47-56 — OAuth2のauthorizeリクエストにstateパラメータを含めていない
。PKCEがあるためCSRFの実害は限定的だが、OAuth2のベストプラクティスではstateパ
ラメータによるCSRF対策が推奨されている（RFC 6749 Section
10.12）。stateがないと、攻撃者が自身のアカウントの認可コードをユーザーに踏ませ
る「ログインCSRF」が可能になる。

9. コールバックでの認可コード再利用保護なし
App.vue:51-76 — /callback処理後にwindow.location.replace('/')でリダイレクトす
るが、ブラウザ履歴に認可コード付きURLが残る可能性がある。Cognito側で認可コード
は1回限りだが、エラー時のリトライ等で同一コードを再送する動線がある。

10. distディレクトリがリポジトリに含まれている
dist/index.html — ビルド成果物がgit管理されている。ビルド済みJSにconfig情報や
ソースマップが含まれうる。

---
重要度まとめ

#: 1
脆弱性: sessionStorageにトークン平文保存
重要度: 中
対策: BFF導入（根本対策）
────────────────────────────────────────
#: 2
脆弱性: トークン存在チェックのみで検証なし
重要度: 高
対策: 署名検証 or exp確認
────────────────────────────────────────
#: 3
脆弱性: JWT署名検証なし
重要度: 高
対策: jwks.jsonで署名検証
────────────────────────────────────────
#: 4
脆弱性: decodeJwtPayloadのエラーハンドリング欠如
重要度: 低
対策: try-catchで保護
────────────────────────────────────────
#: 5
脆弱性: 期限切れトークンでログイン状態維持
重要度: 中
対策: expチェック追加
────────────────────────────────────────
#: 6
脆弱性: config.json改ざんによるOpen Redirect
重要度: 低
対策: リダイレクトURL固定化
────────────────────────────────────────
#: 7
脆弱性: clientId/domain公開
重要度: 低
対策: 許容範囲（レートリミット設定で緩和）
────────────────────────────────────────
#: 8
脆弱性: stateパラメータ欠如（ログインCSRF）
重要度: 中〜高
対策: state生成・検証追加
────────────────────────────────────────
#: 9
脆弱性: 認可コードのURL履歴残存
重要度: 低
対策: replaceStateでURL即時クリア
────────────────────────────────────────
#: 10
脆弱性: distがgit管理
重要度: 低
対策: .gitignoreに追加

特に #8（stateパラメータ欠如） は、PKCEとは独立した攻撃ベクトル（ログインCSRF
）を開くため、学習目的であっても対策推奨です。

❯ nonceは不要？ 

⏺ 良い指摘です。nonceも必要です。

nonceとは

OIDCのnonceパラメータは、IDトークンのリプレイ攻撃を防ぐためのもの。

1. 認可リクエストにランダムなnonceを含めて送信
2. Cognitoが返すIDトークンのクレームに同じnonceが埋め込まれる
3. クライアントがIDトークン受信時に、送った値と一致するか検証する

PKCEとの違い

┌───────┬──────────────────────┬───────────────────────────────────────┐
│       │       保護対象       │             保護するもの              │
├───────┼──────────────────────┼───────────────────────────────────────┤
│ PKCE  │ 認可コードの横取り   │ 認可コード → トークン交換のプロセス   │
├───────┼──────────────────────┼───────────────────────────────────────┤
│ state │ ログインCSRF         │ 認可リクエスト → コールバックの紐付け │
├───────┼──────────────────────┼───────────────────────────────────────┤
│ nonce │ IDトークンのリプレイ │ IDトークン自体の正当性                │
└───────┴──────────────────────┴───────────────────────────────────────┘

3つはそれぞれ異なる攻撃ベクトルに対応しており、互いに代替できません。

具体的な攻撃シナリオ

nonceがない場合、攻撃者が何らかの方法で正規のIDトークンを入手した場合（ログ漏
洩、別セッションからの窃取等）、そのIDトークンを別のセッションに注入できる。no
nceがあれば、セッションごとに異なるnonce値がIDトークンに紐づくため、別セッショ
ンへの注入が検知できる。

現状のコードに不足している処理

cognito.js:47-56 — authorizeリクエストにnonceパラメータがない。

また、仮にnonceを送っても、コールバック時にIDトークン内のnonceクレームを検証す
る処理が一切ないため、両方の実装が必要です。

// 認可リクエスト時: nonce生成 → sessionStorage保存 → パラメータに追加
// コールバック時:   IDトークンのnonce === sessionStorageのnonce を検証