#===============================================================================
# SQS モジュール - メインキューと Dead Letter Queue
#===============================================================================
#
# 【SQS の種類について】
# AWS SQS には2種類のキューがあります：
#
# 1. 標準キュー（Standard Queue）- このモジュールで使用
#    - ほぼ無制限のスループット
#    - 最低1回の配信保証（At-least-once delivery）
#    - ベストエフォート順序（順序が保証されない場合がある）
#    - 用途: 高スループットが必要、順序が重要でない場合
#
# 2. FIFO キュー（First-In-First-Out）
#    - 秒間300メッセージ（バッチ処理で3000メッセージ）
#    - 正確に1回の処理保証（Exactly-once processing）
#    - 厳密な順序保証
#    - キュー名は .fifo で終わる必要がある
#    - 用途: 順序が重要、重複処理を避けたい場合
#
#===============================================================================
# 【Dead Letter Queue (DLQ) パターンについて】
#===============================================================================
#
# DLQ は処理に失敗したメッセージを隔離するためのキューです。
#
# メッセージのライフサイクル:
# 1. プロデューサーがメインキューにメッセージ送信
# 2. コンシューマーがメッセージを受信（可視性タイムアウト開始）
# 3. 処理成功 → メッセージ削除
# 4. 処理失敗 → 可視性タイムアウト後にキューに戻る
# 5. max_receive_count 回失敗 → DLQ に移動
#
# DLQ のメリット:
# - 問題のあるメッセージを隔離し、正常なメッセージ処理を継続
# - 失敗したメッセージを後で分析・再処理可能
# - アラート設定で問題を早期発見
#
#===============================================================================

#-------------------------------------------------------------------------------
# Dead Letter Queue (DLQ)
#-------------------------------------------------------------------------------
# 処理に繰り返し失敗したメッセージを格納するキュー
# メインキューより先に作成する必要がある（リドライブポリシーで参照するため）
#-------------------------------------------------------------------------------
resource "aws_sqs_queue" "dead_letter_queue" {
  # キュー名: プロジェクト名-orders-dlq-環境名
  name = "${var.project_name}-orders-dlq-${var.environment}"

  #-----------------------------------------------------------------------------
  # メッセージ保持期間（Message Retention Period）
  #-----------------------------------------------------------------------------
  # メッセージがキューに保持される最大時間
  # 範囲: 60秒 〜 1,209,600秒（14日間）
  # DLQ は問題調査のため、最大の14日間に設定
  # 14日 = 14 * 24 * 60 * 60 = 1,209,600秒
  message_retention_seconds = 1209600

  #-----------------------------------------------------------------------------
  # 可視性タイムアウト（Visibility Timeout）
  #-----------------------------------------------------------------------------
  # メッセージ受信後、他のコンシューマーから見えなくなる時間
  # この間にメッセージを処理・削除する必要がある
  # タイムアウト後、メッセージは再びキューに表示される
  # 
  # 設定のコツ:
  # - Lambda のタイムアウトの6倍が推奨
  # - 短すぎる: 処理中に再配信され重複処理
  # - 長すぎる: 失敗時の再試行が遅くなる
  visibility_timeout_seconds = 30

  #-----------------------------------------------------------------------------
  # 暗号化設定（Server-Side Encryption）
  #-----------------------------------------------------------------------------
  # SSE-SQS: SQS 管理のキーで暗号化（追加コストなし）
  # SSE-KMS: 自分で管理する KMS キーで暗号化（より細かい制御、コストあり）
  #
  # sqs_managed_sse_enabled = true で SSE-SQS を有効化
  # kms_master_key_id を指定すると SSE-KMS を使用
  sqs_managed_sse_enabled = true

  tags = merge(
    var.tags,
    {
      Name        = "${var.project_name}-orders-dlq-${var.environment}"
      Environment = var.environment
      Purpose     = "Dead Letter Queue for failed messages"
    }
  )
}

#-------------------------------------------------------------------------------
# メインキュー（Orders Queue）
#-------------------------------------------------------------------------------
# 注文メッセージを処理するためのメインキュー
# Lambda からトリガーされ、処理に失敗したメッセージは DLQ に移動
#-------------------------------------------------------------------------------
resource "aws_sqs_queue" "main_queue" {
  # キュー名: プロジェクト名-orders-queue-環境名
  name = "${var.project_name}-orders-queue-${var.environment}"

  #-----------------------------------------------------------------------------
  # メッセージ保持期間
  #-----------------------------------------------------------------------------
  # デフォルト: 4日間（345600秒）
  # 処理が滞った場合でもメッセージを失わないよう十分な期間を設定
  message_retention_seconds = var.message_retention_seconds

  #-----------------------------------------------------------------------------
  # 可視性タイムアウト
  #-----------------------------------------------------------------------------
  # Lambda 関数のタイムアウト時間を考慮して設定
  # Lambda タイムアウト × 6 が AWS 推奨
  visibility_timeout_seconds = var.visibility_timeout_seconds

  #-----------------------------------------------------------------------------
  # 受信待機時間（Receive Wait Time） - ロングポーリング設定
  #-----------------------------------------------------------------------------
  # 【ショートポーリング vs ロングポーリング】
  #
  # ショートポーリング（receive_wait_time_seconds = 0）:
  # - 即座にレスポンスを返す
  # - メッセージがなくても空のレスポンス
  # - API コールが多くなりコスト増
  # - レイテンシは低い
  #
  # ロングポーリング（receive_wait_time_seconds = 1-20）:
  # - メッセージが届くまで待機（最大20秒）
  # - 空のレスポンスが減少
  # - API コール数削減でコスト削減
  # - CPU 使用率も低下
  #
  # 推奨: 20秒（最大値）でコスト効率最大化
  receive_wait_time_seconds = 20

  #-----------------------------------------------------------------------------
  # 最大メッセージサイズ
  #-----------------------------------------------------------------------------
  # 範囲: 1,024バイト（1KB）〜 262,144バイト（256KB）
  # デフォルト: 256KB
  # 大きなペイロードは S3 に格納し、S3 の参照をメッセージに含める
  max_message_size = 262144

  #-----------------------------------------------------------------------------
  # 遅延秒数（Delay Seconds）
  #-----------------------------------------------------------------------------
  # メッセージがキューに入ってから、コンシューマーに見えるまでの遅延
  # 範囲: 0秒 〜 900秒（15分）
  # 用途: 処理のタイミング調整、依存処理の完了待ち
  delay_seconds = 0

  #-----------------------------------------------------------------------------
  # リドライブポリシー（Redrive Policy）
  #-----------------------------------------------------------------------------
  # 処理失敗時に DLQ にメッセージを移動する設定
  #
  # deadLetterTargetArn: 移動先の DLQ の ARN
  # maxReceiveCount: この回数受信されると DLQ に移動
  #   - 1: 1回失敗で即 DLQ（厳格）
  #   - 3-5: 一般的な設定（一時的な障害に対応）
  #   - 10以上: リトライを多く許容
  #
  # 注意: maxReceiveCount はメッセージが「受信された」回数
  # 可視性タイムアウト内に削除されないと受信回数がカウントアップ
  redrive_policy = jsonencode({
    deadLetterTargetArn = aws_sqs_queue.dead_letter_queue.arn
    maxReceiveCount     = var.max_receive_count
  })

  #-----------------------------------------------------------------------------
  # 暗号化設定
  #-----------------------------------------------------------------------------
  sqs_managed_sse_enabled = true

  tags = merge(
    var.tags,
    {
      Name        = "${var.project_name}-orders-queue-${var.environment}"
      Environment = var.environment
      Purpose     = "Main queue for order processing"
    }
  )
}

#===============================================================================
# 【補足: SQS と Lambda の連携パターン】
#===============================================================================
#
# 1. イベントソースマッピング（推奨）
#    - Lambda が自動的に SQS をポーリング
#    - バッチサイズ設定で効率的な処理
#    - 同時実行数の制御が可能
#
# 2. 手動ポーリング
#    - アプリケーションコードで ReceiveMessage を呼び出し
#    - より細かい制御が可能
#    - EC2/ECS で実行するワーカーに適している
#
# 【コスト最適化のポイント】
# - ロングポーリング（20秒）を使用
# - バッチ処理でメッセージをまとめて処理
# - 不要なキューは削除
# - CloudWatch アラームで監視
#
#===============================================================================
