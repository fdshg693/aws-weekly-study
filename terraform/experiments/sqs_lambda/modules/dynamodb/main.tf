#===============================================================================
# DynamoDB テーブル モジュール
#===============================================================================
# 
# DynamoDB は AWS のフルマネージド NoSQL データベースサービスです。
# 
# ■ DynamoDB の特徴:
#   - サーバーレス: インフラ管理不要、自動スケーリング
#   - 高可用性: 3つの AZ に自動レプリケーション
#   - 低レイテンシー: ミリ秒単位の応答時間
#   - 柔軟なスキーマ: アイテムごとに異なる属性を持てる
#
# ■ キー設計のベストプラクティス:
#   1. パーティションキー: データを均等に分散させる値を選択
#      - 良い例: UUID、ユーザーID + タイムスタンプ
#      - 悪い例: 日付のみ（ホットパーティション発生）
#   
#   2. ソートキー: 範囲クエリが必要な属性を選択
#      - 時系列データ、階層データに有効
#
# ■ 課金モードの選択:
#   - PAY_PER_REQUEST: トラフィックが予測困難な場合、開発環境
#   - PROVISIONED: トラフィックが予測可能な場合、コスト最適化
#
#===============================================================================

#-------------------------------------------------------------------------------
# DynamoDB テーブル - 注文データ用
#-------------------------------------------------------------------------------
resource "aws_dynamodb_table" "orders" {
  #-----------------------------------------------------------------------------
  # 基本設定
  #-----------------------------------------------------------------------------

  # テーブル名
  # 命名規則: {プロジェクト名}-{用途}-{環境}
  # 例: myapp-orders-dev, myapp-orders-prod
  name = "${var.project_name}-orders-${var.environment}"

  #-----------------------------------------------------------------------------
  # キー設計
  #-----------------------------------------------------------------------------
  # 
  # ■ パーティションキー (HASH)
  #   - テーブル内でアイテムを一意に識別するための主キーの一部
  #   - DynamoDB はこの値をハッシュ化してデータを分散配置
  #   - 高カーディナリティ（多様な値）を持つ属性を選択すべき
  #
  # ■ ソートキー (RANGE) - オプション
  #   - パーティション内でアイテムを並べ替えるためのキー
  #   - 範囲クエリ（BETWEEN, >, <）が可能になる
  #   - 同じパーティションキーを持つ複数アイテムを格納可能
  #
  # 今回の設計:
  #   order_id + created_at の複合キー
  #   → 同じ注文IDで複数の履歴（更新、キャンセル等）を保持可能
  #
  hash_key  = "order_id"   # パーティションキー
  range_key = "created_at" # ソートキー

  #-----------------------------------------------------------------------------
  # 属性定義
  #-----------------------------------------------------------------------------
  # 
  # 注意: ここで定義するのはキー属性のみ
  # DynamoDB はスキーマレスなので、他の属性は定義不要
  # アイテム挿入時に任意の属性を追加可能
  #
  # type の選択肢:
  #   - S: String（文字列）
  #   - N: Number（数値）- 内部的には文字列として保存
  #   - B: Binary（バイナリ）
  #
  attribute {
    name = "order_id"
    type = "S" # String型 - UUIDや注文番号を想定
  }

  attribute {
    name = "created_at"
    type = "S" # String型 - ISO 8601形式推奨（例: 2024-01-15T10:30:00Z）
  }

  # GSI用の属性も定義が必要
  attribute {
    name = "status"
    type = "S" # String型 - pending, processing, completed, cancelled 等
  }

  #-----------------------------------------------------------------------------
  # 課金モード（キャパシティモード）
  #-----------------------------------------------------------------------------
  # 
  # ■ PAY_PER_REQUEST（オンデマンドモード）
  #   - リクエスト数に応じた従量課金
  #   - 自動スケーリング、キャパシティ計画不要
  #   - トラフィックが予測困難な場合に最適
  #   - 開発/テスト環境に推奨
  #   - 急激なトラフィック増加にも対応
  #
  # ■ PROVISIONED（プロビジョンドモード）
  #   - 事前にキャパシティ（RCU/WCU）を設定
  #   - 予測可能なワークロードでコスト効率が良い
  #   - Auto Scaling と組み合わせて使用可能
  #   - 本番環境で安定したトラフィックがある場合に推奨
  #
  # RCU (Read Capacity Unit): 4KB/秒 の読み取り
  # WCU (Write Capacity Unit): 1KB/秒 の書き込み
  #
  billing_mode = "PAY_PER_REQUEST"

  # PROVISIONED モードの場合の設定例（参考）:
  # billing_mode   = "PROVISIONED"
  # read_capacity  = 5   # 5 RCU
  # write_capacity = 5   # 5 WCU

  #-----------------------------------------------------------------------------
  # Global Secondary Index (GSI)
  #-----------------------------------------------------------------------------
  # 
  # ■ GSI とは？
  #   - メインテーブルとは異なるパーティションキー/ソートキーでクエリ可能
  #   - テーブルとは独立したキャパシティを持つ
  #   - 最大20個まで作成可能
  #   - 非同期でデータが複製される（結果整合性）
  #
  # ■ LSI (Local Secondary Index) との違い:
  #   - LSI: パーティションキーは同じ、ソートキーのみ変更可能
  #   - LSI: テーブル作成時のみ作成可能（後から追加不可）
  #   - LSI: 強い整合性読み取りが可能
  #
  # ■ GSI 設計のポイント:
  #   - 頻繁に使用するクエリパターンに基づいて設計
  #   - projection_type で必要な属性のみ投影してコスト削減
  #
  # 今回の GSI: ステータス別に注文を検索するため
  # ユースケース: 「pending 状態の注文を新しい順に取得」
  #
  global_secondary_index {
    name = "status-index"

    # GSI のキー設計
    hash_key  = "status"     # ステータスでパーティション
    range_key = "created_at" # 作成日時でソート

    # 射影タイプ（GSI に含める属性）
    # 
    # ■ projection_type の選択肢:
    #   - ALL: 全ての属性を含める（ストレージコスト増）
    #   - KEYS_ONLY: キー属性のみ（最小コスト）
    #   - INCLUDE: 指定した属性のみ（バランス型）
    #
    # KEYS_ONLY を選択した場合、他の属性が必要な時は
    # メインテーブルへの追加クエリが必要（追加コスト発生）
    #
    projection_type = "ALL"

    # INCLUDE の場合の設定例:
    # projection_type   = "INCLUDE"
    # non_key_attributes = ["customer_id", "total_amount"]
  }

  #-----------------------------------------------------------------------------
  # Point-in-Time Recovery (PITR)
  #-----------------------------------------------------------------------------
  # 
  # ■ PITR とは？
  #   - 過去35日間の任意の時点にテーブルを復元可能
  #   - 継続的なバックアップを自動作成
  #   - 誤削除、アプリケーションエラーからの復旧に有効
  #
  # ■ 料金:
  #   - ストレージ料金のみ（GB/月）
  #
  # ■ 環境別の推奨:
  #   - 本番環境: 必ず有効化
  #   - 開発環境: コスト削減のため無効でも可
  #
  point_in_time_recovery {
    enabled = false # 開発環境では無効、本番では true に変更推奨
  }

  #-----------------------------------------------------------------------------
  # TTL (Time to Live)
  #-----------------------------------------------------------------------------
  # 
  # ■ TTL とは？
  #   - 指定した時刻以降、アイテムを自動削除する機能
  #   - 削除は無料（WCU を消費しない）
  #   - 実際の削除は指定時刻から48時間以内に実行
  #
  # ■ ユースケース:
  #   - セッションデータの自動削除
  #   - ログデータの保持期間管理
  #   - 一時的なキャッシュデータ
  #
  # ■ 注意点:
  #   - TTL 属性は Unix エポック秒（数値）で指定
  #   - 過去の時刻を設定すると即座に削除対象になる
  #   - 削除は非同期、正確なタイミングは保証されない
  #
  # 使用例: アイテム挿入時に expires_at を設定
  # {
  #   "order_id": "ORD-001",
  #   "created_at": "2024-01-15T10:30:00Z",
  #   "expires_at": 1705312200  # Unix timestamp
  # }
  #
  ttl {
    enabled        = true
    attribute_name = "expires_at" # TTL を判定する属性名
  }

  #-----------------------------------------------------------------------------
  # 暗号化設定
  #-----------------------------------------------------------------------------
  # 
  # ■ DynamoDB の暗号化オプション:
  #
  # 1. AWS 所有キー (DEFAULT) - デフォルト
  #    - AWS が管理する共有キー
  #    - 追加料金なし
  #    - 監査ログなし
  #
  # 2. AWS 管理キー (AWS_OWNED_CMK)
  #    - アカウント専用のキー（aws/dynamodb）
  #    - 追加料金なし
  #    - CloudTrail で監査可能
  #
  # 3. カスタマー管理キー (CUSTOMER_MANAGED_CMK)
  #    - 自分で作成・管理する KMS キー
  #    - キーポリシーで細かいアクセス制御
  #    - KMS 料金が発生
  #    - コンプライアンス要件がある場合に推奨
  #
  # server_side_encryption ブロックを省略するとデフォルト暗号化が適用
  # 明示的に設定する場合:
  #
  # server_side_encryption {
  #   enabled     = true
  #   kms_key_arn = aws_kms_key.dynamodb.arn  # カスタマー管理キーの場合
  # }

  #-----------------------------------------------------------------------------
  # ストリーム設定（オプション）
  #-----------------------------------------------------------------------------
  # 
  # ■ DynamoDB Streams とは？
  #   - テーブルへの変更（挿入、更新、削除）をキャプチャ
  #   - 24時間保持される変更ログ
  #   - Lambda トリガーやレプリケーションに使用
  #
  # ■ stream_view_type の選択肢:
  #   - KEYS_ONLY: キー属性のみ
  #   - NEW_IMAGE: 変更後の完全なアイテム
  #   - OLD_IMAGE: 変更前の完全なアイテム
  #   - NEW_AND_OLD_IMAGES: 変更前後の両方（推奨）
  #
  # ■ ユースケース:
  #   - 変更をトリガーに Lambda 関数を実行
  #   - 他のテーブルへのレプリケーション
  #   - 監査ログの作成
  #   - Elasticsearch への同期
  #
  # 将来の拡張用に有効化（Lambda トリガー等で使用予定）
  stream_enabled   = true
  stream_view_type = "NEW_AND_OLD_IMAGES"

  #-----------------------------------------------------------------------------
  # タグ
  #-----------------------------------------------------------------------------
  # 
  # タグはリソース管理、コスト配分、アクセス制御に重要
  # 
  tags = merge(
    {
      Name        = "${var.project_name}-orders-${var.environment}"
      Environment = var.environment
      ManagedBy   = "terraform"
      Purpose     = "Order data storage"
    },
    var.tags
  )

  #-----------------------------------------------------------------------------
  # ライフサイクル設定
  #-----------------------------------------------------------------------------
  # 
  # prevent_destroy: 誤削除防止（本番環境で推奨）
  # ignore_changes: 特定の属性変更を無視
  #
  # lifecycle {
  #   prevent_destroy = true  # 本番環境で有効化推奨
  # }
}

#===============================================================================
# 追加設定オプション（参考）
#===============================================================================
#
# ■ Auto Scaling（PROVISIONED モード時）
# 
# resource "aws_appautoscaling_target" "dynamodb_table_read_target" {
#   max_capacity       = 100
#   min_capacity       = 5
#   resource_id        = "table/${aws_dynamodb_table.orders.name}"
#   scalable_dimension = "dynamodb:table:ReadCapacityUnits"
#   service_namespace  = "dynamodb"
# }
#
# ■ グローバルテーブル（マルチリージョンレプリケーション）
#
# resource "aws_dynamodb_table" "orders" {
#   ...
#   replica {
#     region_name = "ap-northeast-1"
#   }
#   replica {
#     region_name = "us-west-2"
#   }
# }
#
# ■ VPC エンドポイント（プライベート接続）
#
# resource "aws_vpc_endpoint" "dynamodb" {
#   vpc_id       = aws_vpc.main.id
#   service_name = "com.amazonaws.${var.region}.dynamodb"
# }
#
#===============================================================================
